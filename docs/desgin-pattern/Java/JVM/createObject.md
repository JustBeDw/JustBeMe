## 对象的创建

​		创建一个对象，通常仅仅是一个`new`关键字。而Java虚拟机上，遇到了**new**的指令，先去常量池定位一个类的符号引用，检查是否被**加载、解析和初始化**。如果没有，则进行相应的加载过程，类加载检查通过后，将为新生对象分配内存（类所需内存在加载后完全可知）放在**堆**中。  
​		如果堆中内存是绝对规整的，所有使用过的内存放一边，空闲的内存放一边，中间放着一个指针作为分界点的指示器，这种分配方式称为：`指针碰撞`。  
​		如果堆中内存并不是规整的，空闲与用过的内存相互交错，虚拟机就必须维护一个列表，记录那些可用，那些不可用，这中分配方式称为：`空闲列表`。  
​		其次进行内存空间的初始化，零值。如果使用TLAB可以提前至之前此操作，不用赋初始值就可以使用。

​		在创建对象过程中还需要考虑的问题是，创建对象仅仅修改一个指针所指向的位置，在并发的情况下，并不是线程安全的，会出现对象A分配空间，指针还没来得及修改，对象B同时使用了原来的指针来分配内存。  
​		解决此问题两种办法：一、同步处理，**CAS** 保证更新操作的原子性。二、内存分配的动作按照线程规划在不同的空间中进行，即每个线程在Java堆先预先分配一小块内存，成为本地线程分配缓冲（Thread Local Allocation Buffer）。

## 对象内存布局

对象在内存中存储的布局可以分为3个区域：对象头，实例数据和对齐填充。

对象头：一、存储对象运行时数据（哈希码、GC分代年龄、锁状态标志、持有锁），这部分数据的长度在32位和64位的虚拟机中分别为32Bit和64Bit。二、类型指针，对象指向它的类元数据的指针，虚拟机通过指针来确定这个对象是哪个类的实例。

实例数据：这部分是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。这部分的存储顺序都会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为long/doubles、ints、shorts/chars.....可以发现，等宽的字段总是分配到一起。

对齐填充：这部分并不是必须的，因为要求对象起始地址必须是8字节的整数倍。

## 对象访问定位 

目前定位对象所在位置的方式两种：句柄和直接指针。

句柄：需要在堆空间中开辟一个句柄池，栈中的引用指向句柄池，句柄池再指向实例对象（堆）的数据和类型数据（栈）。类似这样的（（句柄池）（实例池））

直接指针：直接指向堆中，堆中的实例再只指向对象类型数据（栈）。类似这样的（（实例））。

好处：句柄可以稳定地址，对象被移动只会改变句柄的实力数据指针，引用不会被修改。直接指针则是速度更快，节省了一次指针定位的开销（常用）。

------

*参考书籍《深入理解 Java虚拟机》——周志明*