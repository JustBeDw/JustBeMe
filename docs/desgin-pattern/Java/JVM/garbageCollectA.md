## 判断对象存活算法

#### 引用计数法

如果对象被引用，则计数器 `+1`，引用失效，则计数器 `-1`，只要计数器为 `0` 的对象，就是不可再使用的。

引用计数法，简单，效率高，但是无法解决对象之间的循环引用的问题。  
Object A = Object B，Object B = Object A，这样无法通知GC回收，因为计数器永远不等于0.

#### 可达性算法

从`GC Roots` 这个根节点，顺着往下走，所走过的路径为**引用链**。当一个对象到**GC Roots**没有任何引用链的时候，就通知GC回收。

“在JDK1.2之后，Java对引用概念进行了补充，将引用分为强引用、软引用、弱引用和虚引用。  
**强引用**：就是使用**new**关键字，只要强引用还在就不会被回收掉。  
**软引用**：描述一些有用但不是必需的对象。若发生内存溢出之前，会把这些对象进行二次回收，如果回收还是不够，将抛出内存溢出异常。    
**弱引用**：比软引用还弱一些，只能生存到下一次回收之前，无论内存是否够用，都将回收。  
**虚引用**：幽灵引用，目的就是为了能在这个对象被收集器回收时收到一个通知。”——《深入理解 Java虚拟机》

## 垃圾回收算法

#### 标记—清除

见名知意，先标记再清理！首先标记出所有需要回收的对象，在标记完成后，统一回收被标记的对象。  
有两点不足之处：  
一、效率太慢，标记和清除都很慢；  
二、空间问题，会产生大量的内存碎片（不连续的内存），当需要大量连续的内存时，不得不进行一次回收。

#### 复制算法

为了解决效率问题，复制算法可以将可用内存按照容量大小分为大小相等的两块，每次只使用一块。当其中一块用完，就将存货对象赋值到另一块，再把使用过的一次清理掉。这样使得，每次都进行一大块一大块的回收。不用考虑内存碎片的问题，只要移动堆顶指针，按顺序分配内存，简单高效。

#### 标记—整理

标记清楚算法的标记过程一样，后续则是进行整理，所有存货的对象向一端移动，解决了内存碎片的问题。

#### 分代收集算法

根据存活周期不同，将内存划分几块。一般是把堆分为新生代和老年代，再根据各个代进行适合的算法，如，新生代每次都有大批的对象死亡，则使用复制算法；若对象存活率高，没有额外的空间则使用标记——整理算法。