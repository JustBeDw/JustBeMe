## 垃圾回收器——新生代

#### Serial

串行收集器

简单，只会使用一个线程去做回收垃圾的任务，但是进行垃圾回收时，会暂停所有工作线程，直至回收完毕。

#### ParNew

并行收集器

可以多个线程，一起执行垃圾回收任务。其他与串行收集器没有什么区别。

**并发：**多条线程垃圾回收任务和用户线程一起工作。

**并行：**多条线程垃圾回收任务一起工作，但用户线程仍在等待。

#### Parallel Scanvenge

吞吐量 = 运行用户代码所用时间 / 总时间

此垃圾回收器，目的是为了提高吞吐量，即缩短垃圾回收时所停顿的时间。

## 垃圾回收器——老年代

#### Serial Old

Serial的老年代版本，使用算法**标记——整理**。

#### Parallel Old

Parallel Scanvenge的老年代版本，使用算法**标记——整理**。

#### CMS

Concurrent Mark Sweep，以获取最短回收停顿时间为目标的收集器。很多Java应用集在互联网站或者B/S系统的服务器上，这类应用重视服务的响应速度，希望系统停顿时间最短，给用户带来好的体验。  
CMS是**基于标记——清除**算法实现的，他的运作过程更复杂，4个步骤：

* **初始标记**：标记GC Roots 能关联到的对象，速度很快。
* **并发标记**：执行GC Roots Tracing（可达性分析）。
* **重新标记**：修正并发标记期间用户程序继续运作导致标记产生变动的那一部分对象的标记记录。
* **并发清除**：垃圾回收动作与用户线程一起执行。

但CMS有3个**缺点**：

* CMS对CPU资源非常敏感。

* CMS无法处理浮动垃圾。

* CMS是基于标记——清除实现的，会有碎片内存。

*(见《深入理解 Java虚拟机》P82)*

## G1

G1垃圾回收器，是当今收集器技术发展最前沿成果之一，有以下特点：

* **并行并发**：使用多核多cpu缩短停顿时间。
* **分代收集**：分代概念保留。
* **空间整合**：基于 标记——整理 算法，解决了碎片内存的问题。
* **可预测的停顿**：建立可预测的停顿时间模型，追求低停顿。

G1运作过程有4步：

* **初始标记**：标记GC Roots 关联的对象。
* **并发标记**：标记存活对象，进行GC Roots Tracing （可达性分析）。
* **最终标记**：记录在并发标记过程中导致标记产生变动的一部分标记。
* **筛选删除**：先对各个Region（大小相等的独立区域）的回收价值和成本进行排序，根据所期望的GC停顿时间制定回收计划，这个过程也是可以和用户程序并发执行。

------

*参考书籍《深入理解 Java虚拟机》——周志明*